# = extension_attribute.rb.rb
#
# Author:: Chris Lasell, Pixar Animation Studios (mailto:chrisl@pixar.com)
# Copyright:: Copyright (c) 2013 Pixar Animation Studios
#
# A class representing an Extension Attribute as defined and stored in the JSS.
# NOTE: This does NOT give access to the values generated by each client computer
# using the E.A.  For that, see site_extension_attributes.rb and the mixin-module
# it provides
#


module PixJSS

  ### 
  ### Methods and classes related to Extension Attributes as stored in the JSS.
  ### For methods and constants giving access to these values via a JSSComputer instance,
  ### see the SiteExtensionAttributes submodule, which is mixed-in to the JSSComputer class
  ### 
  ###
  
  #####################################
  # Constants
  ##################################### 
  
  ### jss tables and the fields we care abot in them.
  
  # the extension attribute definitions
  EXT_ATTR_TABLE = "extension_attributes"
  EXT_ATTR_ATTRS_TO_JSS_FIELDS = {
    :id => 'extension_attribute_id',
    :name => 'display_name',
    :description => 'description',
    :script => 'script_contents_mac'
  }
  EA_MAP = EXT_ATTR_ATTRS_TO_JSS_FIELDS
  
  # the extension attrib values
  EXT_ATTR_VALUES_TABLE = "extension_attribute_values"
  EXT_ATTR_VALUES_ATTRS_TO_JSS_FIELDS = {
    :eaid => 'extension_attribute_id',
    :rid => 'report_id',
    :value => 'value_on_client'
  }
  EAV_MAP = EXT_ATTR_VALUES_ATTRS_TO_JSS_FIELDS
  
  # the reports that generated the values
  REPORTS_TABLE = 'reports'
  REPORT_ATTRS_TO_JSS_FIELDS = {
    :id => 'report_id',
    :compid => 'computer_id',
    :timestamp => 'date_entered'
  }
  RPT_MAP = REPORT_ATTRS_TO_JSS_FIELDS
  
  
  #####################################
  # Module Variables
  ##################################### 
  
  ### Stores a hash of all extension_attributes in the JSS keyed by names
  ### values are JSSExtAttrib objects
  ### Access is via the computer_groups module method
  @@extension_attributes = nil
  
  
  #####################################
  # Module Methods
  ##################################### 
  
  ###
  ### Return an hash of all extension_attributes in the JSS keyed by names.
  ### values are JSSExtAttrib objects
  ###
  def extension_attributes(refresh = nil)
    @@extension_attributes = nil if refresh
    return @@extension_attributes if @@extension_attributes
    
    @@extension_attributes = {}
    check_connection
    
    theQuery = "SELECT #{EA_MAP[:id]}, #{EA_MAP[:name]}, #{EA_MAP[:description]}, #{EA_MAP[:script]} FROM #{EXT_ATTR_TABLE}" 
    @@db_cnx.query(theQuery).each_hash do |ea|
      @@extension_attributes[ea[EA_MAP[:name]]] = JSSExtAttrib.new :id => ea[EA_MAP[:id]], :name => ea[EA_MAP[:name]], :desc => ea[EA_MAP[:descriptino]], :script => ea[EA_MAP[:script]]
    end # each hash
    
    @@extension_attributes
  end # def
  
  ####################################
  # Classes
  ##################################### 
  
  
  ### 
  ### An extension attribute as defined in the JSS
  ###
  class JSSExtAttrib
    include PixJSS
    
    ######################
    # Attributes
    ######################
    
    # Integer - the jss id of the ext attrib
    attr_reader :id
    
    # Strng - the display name of the ext attrib
    attr_reader :name
    
    # String - description of the ext attrib
    attr_reader :description
    alias desc description
    
    # String - the script that generates the value on the clients
    attr_reader :script
    
    ######################
    # Methods
    ######################
    
    # Initializing args must include :name OR :id, and either :lookup, to look up the EA from the JSS
    # or all other values needed to make the object (:id, :name, :desc and :script)
    def initialize(args = {})
      if args[:lookup] 
        raise PixJSS::MissingDataError, "lookups requre a :name or :id" unless args[:id] or args[:name]
        
        where_clause = args[:id] ? "#{EA_MAP[:id]} = '#{args[:id]}'" : "#{EA_MAP[:name]} = '#{args[:name]}'"
        result = @@db_cnx.query "SELECT #{EA_MAP[:id]}, #{EA_MAP[:name]}, #{EA_MAP[:description]}, #{EA_MAP[:script]} FROM #{EXT_ATTR_TABLE} WHERE #{where_clause}"
        
        raise PixJSS::NoSuchItemError if result.count == 0
        raise "Ambiguous Search" if result.count > 1
        
        data = result.fetch_hash
        @id = data[EA_MAP[:id]].to_i
        @name = data[EA_MAP[:name]]
        @description =  data[EA_MAP[:description]]
        @script = data[EA_MAP[:script]] 
      else # no lookup
        raise PixJSS::MissingDataError, "Ext Attribs requre a :name and :id" unless args[:id] and args[:name]
        @id = args[:id].to_i
        @name = args[:name]
        @description = args[:desc]
        @script = args[:script]
      end #if args[:lookup] 
    end # init 
    
    
    
    ###########
    # Return an array of hashes showing the most recent value for this EA on all computers in the JSS.
    # Each hash contains these keys:
    # :computer_name - String
    # :computer_id - Integer
    # :value - String
    # :timestamp  - DateTime
    def latest_values
      check_connection
      the_query = <<-END_Q
      SELECT c.#{CDMAP[:name]} AS cname, c.#{CDMAP[:id]} AS cid,  eav.#{EAV_MAP[:value]} AS value, lreport.report_date AS as_of
      FROM #{COMPUTERS_TABLE} c
        JOIN ( SELECT c.#{CDMAP[:id]}, max(r.#{RPT_MAP[:id]}) as report_id, max(r.#{RPT_MAP[:timestamp]}) as report_date 
            FROM #{REPORTS_TABLE} r JOIN #{COMPUTERS_TABLE} c ON c.#{CDMAP[:id]} = r.#{RPT_MAP[:compid]} GROUP BY c.#{CDMAP[:id]} ) lreport 
          ON c.#{CDMAP[:id]} = lreport.#{CDMAP[:id]}
        JOIN #{EXT_ATTR_VALUES_TABLE} eav
          ON lreport.report_id = eav.#{EAV_MAP[:rid]}
      WHERE eav.#{EAV_MAP[:eaid]} = #{@id} 
        AND eav.#{EAV_MAP[:value]} != '' 
        AND eav.#{EAV_MAP[:value]} IS NOT NULL 
        AND eav.#{EAV_MAP[:value]} != '(null)'
      END_Q
      
      qrez = @@db_cnx.query the_query
      return [] if qrez.count == 0
      latest_vals = []
      
      qrez.each_hash do |comp|
        newhash = {:computer_name => comp['cname'], :computer_id => comp['cid'].to_i, :value => comp['value'], :timestamp => DateTime.parse(comp['as_of']) }
        latest_vals << newhash
      end # each hash
      
      latest_vals
    end # latest values

    ###########
    # Return an array of hashes showing the history of values for this EA on one computer
    # the computer must be specified as a computer name or ID in the JSS.
    # Each hash contains these 2 keys:
    # :value - String
    # :timestamp  - DateTime
    def history(computer)
      check_connection
      
      computer_id = case computer.to_s
        when *computers.keys
          computer
        when *computers.values
          computers.invert[computer]
        else nil
      end # case
      
      raise PixJSS::MissingDataError, "No computer found matching '#{computer}'" unless computer_id
      
      the_query = <<-END_Q
      SELECT eav.#{EAV_MAP[:value]} AS value, r.#{RPT_MAP[:timestamp]} AS timestamp
      FROM #{EXT_ATTR_VALUES_TABLE} eav JOIN #{REPORTS_TABLE} r ON eav.#{EAV_MAP[:rid]} = r.#{RPT_MAP[:id]}
      WHERE r.#{RPT_MAP[:compid]} = #{computer_id}
        AND eav.#{EAV_MAP[:eaid]} = #{@id} 
        AND eav.#{EAV_MAP[:value]} != '' 
        AND eav.#{EAV_MAP[:value]} IS NOT NULL 
        AND eav.#{EAV_MAP[:value]} != '(null)'
      ORDER BY timestamp
      END_Q
      
      qrez = @@db_cnx.query the_query
      return [] if qrez.count == 0
      history = []
      
      qrez.each_hash do |entry|
        newhash = {:value => entry['value'], :timestamp => DateTime.parse(entry['timestamp']) }
        history << newhash
      end # each hash
      history
    end # history
    
    
  end # class JSSExtAttrib
  
  
end # module
